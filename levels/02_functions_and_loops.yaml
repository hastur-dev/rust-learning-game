name: "Level 2: Functions and Loops"
description: "Master functions, loops, structs, and control flow through systematic exploration"
max_turns: 150
width: 6
height: 6
start: [0, 0]

# Simple grid layout with items for systematic collection
grid:
  - ["S", ".", ".", "I", ".", "."]
  - [".", "#", ".", ".", "I", "."]
  - [".", ".", "#", ".", ".", "I"]
  - ["I", ".", ".", "#", ".", "."]
  - [".", "I", ".", ".", "#", "."]
  - [".", ".", ".", ".", ".", "G"]

items:
  - name: "key"
    pos: [3, 0]
  - name: "coin" 
    pos: [4, 1]
  - name: "gem"
    pos: [5, 2]
  - name: "crystal"
    pos: [0, 3]
  - name: "scroll"
    pos: [1, 4]

enemies: []

completion_flag: "goal"
completion_message: |
  ðŸŽ¯ **LEVEL 2: Functions, Loops, and Structs**
  
  Learn to organize your code effectively and process data systematically!
  
  **ðŸ“‹ TASK 1: Create a Function with Print Statement**
  Create a function called `scan_level()` that contains a print statement and will hold our main logic.
  
  Required:
  ```rust
  fn scan_level() {
      println!("Beginning level scan...");
      // More code will go here in later tasks
  }
  ```
  
  **ðŸ“‹ TASK 2: Add Loop to Scan Each Tile**
  Inside your `scan_level()` function, add nested loops to go through every tile in the 6x6 grid.
  
  Required loop structure:
  ```rust
  for y in 0..6 {
      for x in 0..6 {
          // Move to position and scan
          robot.move_to(x, y);  // You'll need to implement movement
          let scan_result = robot.scan();
      }
  }
  ```
  
  **ðŸ“‹ TASK 3: Create Struct to Track Grid Information**
  Create a struct to store information about each grid position and identify item locations.
  
  Required struct:
  ```rust
  struct GridInfo {
      x: i32,
      y: i32,
      content: String,
  }
  ```
  
  Modify your loop to collect data and print all item locations at the end.
  
  **ðŸ“‹ TASK 4: Create Item Collection Function**
  Create a second function called `grab_if_item()` that takes coordinates and contains an if statement to grab items.
  
  Call this function inside your scanning loop:
  ```rust
  fn grab_if_item(scan_result: &str) {
      if scan_result != "empty" && scan_result != "wall" {
          robot.grab();
          println!("Grabbed: {}", scan_result);
      }
  }
  ```
  
  **ðŸ’¡ Remember: All code must be organized in functions for better structure!**

achievement_message: "Perfect! You've mastered function organization, loops, structs, and conditional logic!"
next_level_hint: "Next level: Error handling and advanced movement patterns"

starting_code: |
  // Level 2: Functions, Loops, and Structs
  // All code must be organized into functions!
  
  // TODO: Task 3 - Define your GridInfo struct here
  // struct GridInfo {
  //     x: i32,
  //     y: i32,
  //     content: String,
  // }
  
  // TODO: Task 1 - Create scan_level function with print statement
  // fn scan_level() {
  //     println!("Beginning level scan...");
  //     
  //     // TODO: Task 2 - Add nested loops here
  //     // for y in 0..6 {
  //     //     for x in 0..6 {
  //     //         // Movement and scanning code
  //     //     }
  //     // }
  // }
  
  // TODO: Task 4 - Create grab_if_item function
  // fn grab_if_item(scan_result: &str) {
  //     // Add if statement to check for items and grab them
  // }
  
  fn main() {
      println!("Level 2: Functions, Loops, and Structs");
      println!("Remember: All code must be in functions!");
      
      // TODO: Call your scan_level() function here
      // scan_level();
      
      // Navigate to goal when done
      println!("All tasks complete! Moving to goal...");
      // You'll need movement code to reach (5,5)
  }

rust_docs_url: "https://doc.rust-lang.org/book/ch03-03-how-functions-work.html"

# Example solution for reference
example_solution: |
  // Example Solution - Level 2: Functions, Loops, and Structs
  
  // Task 3: Define struct to hold grid information
  struct GridInfo {
      x: i32,
      y: i32,
      content: String,
  }
  
  // Helper function for movement (you'll need to implement this based on robot API)
  fn move_to_position(target_x: i32, target_y: i32) {
      // Simple movement implementation
      // In real robot code, you'd need to track current position
      // and move step by step to reach target
      println!("Moving to position ({}, {})", target_x, target_y);
      
      // Example basic movement (replace with proper robot movement)
      // This would need actual robot.move_right(), robot.move_down() etc.
      // For now, assume we can teleport to demonstrate the concept
  }
  
  // Task 1: Function with print statement that will hold main logic
  fn scan_level() {
      println!("Beginning level scan...");
      
      let mut grid_data = Vec::new();
      let mut item_locations = Vec::new();
      
      // Task 2: Loop through each tile in the 6x6 grid
      for y in 0..6 {
          for x in 0..6 {
              // Move to position and scan
              move_to_position(x, y);
              let scan_result = robot.scan();
              
              // Store grid information
              grid_data.push(GridInfo {
                  x: x,
                  y: y,
                  content: scan_result.clone(),
              });
              
              // Task 3: Track item locations for printing
              if scan_result != "empty" && scan_result != "wall" && scan_result != "goal" {
                  item_locations.push((x, y, scan_result.clone()));
              }
              
              // Task 4: Call grab function for each position
              grab_if_item(&scan_result);
          }
      }
      
      // Task 3: Print all item locations found during scan
      println!("=== ITEM LOCATIONS DISCOVERED ===");
      if item_locations.is_empty() {
          println!("No items found on the level");
      } else {
          for (x, y, item_name) in item_locations {
              println!("Item '{}' found at grid position ({}, {})", item_name, x, y);
          }
      }
  }
  
  // Task 4: Second function with if statement for item collection
  fn grab_if_item(scan_result: &str) {
      if scan_result != "empty" && scan_result != "wall" && scan_result != "goal" {
          robot.grab();
          println!("Grabbed: {}", scan_result);
      }
  }
  
  fn main() {
      println!("Level 2: Functions, Loops, and Structs");
      println!("Remember: All code must be in functions!");
      
      // Call the main scanning function
      scan_level();
      
      // Navigate to goal when done
      println!("All tasks complete! Moving to goal...");
      move_to_position(5, 5);  // Goal is at (5,5)
      
      println!("Level 2 complete!");
  }

# Tutorial hints for each task
tutorial_hints:
  task1: |
    **Task 1 Hint: Create Function with Print Statement**
    
    Create a function called `scan_level()` that contains a print statement:
    
    ```rust
    fn scan_level() {
        println!("Beginning level scan...");
        // This function will hold all our scanning logic
    }
    ```
    
    Remember to:
    1. Define the function above `main()`
    2. Use `println!()` macro inside the function
    3. Call the function from `main()` with `scan_level();`
    
  task2: |
    **Task 2 Hint: Add Nested Loops Inside Function**
    
    Add nested loops inside your `scan_level()` function to go through each tile:
    
    ```rust
    fn scan_level() {
        println!("Beginning level scan...");
        
        for y in 0..6 {        // 6x6 grid height
            for x in 0..6 {    // 6x6 grid width
                // Move to position (implement movement logic)
                // robot.move_to(x, y); // You'll need basic movement
                let scan_result = robot.scan();
                println!("Scanned ({}, {}): {}", x, y, scan_result);
            }
        }
    }
    ```
    
    The loops will visit every tile systematically!
    
  task3: |
    **Task 3 Hint: Create Struct and Track Grid Information**
    
    1. First, define the GridInfo struct above all functions:
    ```rust
    struct GridInfo {
        x: i32,
        y: i32,
        content: String,
    }
    ```
    
    2. Inside your loops, collect data and track items:
    ```rust
    let mut item_locations = Vec::new();
    
    for y in 0..6 {
        for x in 0..6 {
            let scan_result = robot.scan();
            
            // Track items for printing
            if scan_result != "empty" && scan_result != "wall" {
                item_locations.push((x, y, scan_result.clone()));
            }
        }
    }
    
    // Print all item locations
    for (x, y, item) in item_locations {
        println!("Item '{}' at ({}, {})", item, x, y);
    }
    ```
    
  task4: |
    **Task 4 Hint: Create Second Function with If Statement**
    
    Create a `grab_if_item()` function and call it from inside your loop:
    
    ```rust
    fn grab_if_item(scan_result: &str) {
        if scan_result != "empty" && scan_result != "wall" && scan_result != "goal" {
            robot.grab();
            println!("Grabbed: {}", scan_result);
        }
    }
    ```
    
    Then inside your scanning loop:
    ```rust
    for y in 0..6 {
        for x in 0..6 {
            let scan_result = robot.scan();
            grab_if_item(&scan_result);  // Call the grab function
        }
    }
    ```
    
    This separates the logic into organized functions!