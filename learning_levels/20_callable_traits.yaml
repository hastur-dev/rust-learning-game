# Level 20: Callable Traits Mastery
# This level teaches Fn, FnMut, FnOnce traits for functional programming
# Players learn closures, function pointers, and higher-order functions

level_id: 20
name: "Robot Behavior Programming Lab"
description: "üß† Enter the Robot AI Lab! Program advanced behavior patterns using closures - teach your robot to think, adapt, and evolve its decision-making!"
next_level: 21

# Grid layout: 18x10 with functional programming zones
grid:
  width: 18
  height: 10
  start_position: [1, 1]

walls:
  - [0, 0, 17, 0]    # Top wall
  - [0, 9, 17, 9]    # Bottom wall
  - [0, 0, 0, 9]     # Left wall
  - [17, 0, 17, 9]   # Right wall
  - [6, 1, 6, 8]     # Closure zone separator
  - [12, 1, 12, 8]   # Function trait separator
  - [3, 3, 15, 3]    # Horizontal divider
  - [3, 6, 15, 6]    # Lower divider

# Items teach different callable trait concepts
items:
  # Task 1: Basic closures and Fn trait
  - position: [2, 2]
    item_type: "robot_decision_matrix"
    name: "Robot Decision Pattern Analyzer"
    description: "üß† BREAKTHROUGH! Discover how to program pure decision patterns that your robot can reuse infinitely without changing its core logic!"
    content: |
      ü§ñ ROBOT DECISION PROGRAMMING LAB ü§ñ

      üéØ PURE BEHAVIOR PATTERNS DISCOVERED:
      - Pathfinding Filter: Should robot avoid this obstacle? (reusable logic)
      - Coordinate Transform: Convert sensor data to movement commands (pure function)
      - Safety Validator: Is this action safe to execute? (stateless safety check)
      - Display Formatter: Convert robot thoughts to human-readable text (immutable)

      üß† ROBOT AI PRINCIPLE: Some robot behaviors should be PURE - they analyze
      the situation and make recommendations without changing the robot's internal
      state. These can be called repeatedly with the same inputs to get the same
      results.

      üéØ BEHAVIOR PROGRAMMING MISSION:
      - Create reusable decision closures using Fn trait (never modify robot state)
      - Program obstacle avoidance patterns that work in any situation
      - Design validation logic that keeps the robot safe
      - Build formatters that translate robot thoughts into readable output

      üß† ROBOT LEARNS: Pure behaviors = reliable decision-making patterns

      üèÜ SUCCESS: Robot can now make consistent, reusable decisions in any scenario!
    requirements:
      - "Create closures that implement Fn trait for multiple calls"
      - "Accept function parameters using Fn trait bounds"
      - "Implement filtering and mapping with immutable closures"
      - "Demonstrate closure capture of immutable references"

  # Task 2: Mutable closures with FnMut trait
  - position: [8, 2]
    item_type: "robot_learning_core"
    name: "Robot Learning and Adaptation Core"
    description: "üß† EVOLUTION MODE! Your robot needs to LEARN and ADAPT! Program behaviors that update the robot's knowledge as it experiences the world."
    content: |
      üöÄ ROBOT ADAPTIVE LEARNING SYSTEM üöÄ

      üìä LEARNING BEHAVIORS REQUIRED:
      - Experience Counter: Track how many obstacles robot has encountered (learns patterns)
      - Efficiency Calculator: Running average of energy usage (adapts performance)
      - Position Memory: Build map of visited locations (updates spatial knowledge)
      - Mission Logger: Record successful strategies (evolves tactics)

      üß† ROBOT EVOLUTION PRINCIPLE: Advanced robots must LEARN from experience!
      Unlike pure decision patterns, learning behaviors MODIFY the robot's
      internal knowledge. Each interaction updates the robot's understanding
      of the world, making it smarter and more efficient.

      üéØ ADAPTIVE PROGRAMMING MISSION:
      - Create learning closures using FnMut trait (can modify robot state)
      - Program experience accumulation that improves robot decision-making
      - Design adaptive systems that update performance based on results
      - Build memory systems that help robot navigate more efficiently

      üß† ROBOT BREAKTHROUGH: Learning behaviors = evolving intelligence

      üèÜ EVOLUTION COMPLETE: Robot becomes smarter with every action and learns from mistakes!
    requirements:
      - "Create closures implementing FnMut trait for mutable state"
      - "Accept function parameters with FnMut trait bounds"
      - "Implement accumulator patterns with mutable closures"
      - "Handle mutable capture and state modification"

  # Task 3: Move closures with FnOnce trait
  - position: [14, 2]
    item_type: "ownership_transfer"
    name: "Ownership Transfer Processor"
    description: "System requiring closures that take ownership of captured variables"
    content: |
      // Operations requiring FnOnce trait for ownership transfer
      Resource Management:
      - Consume: Take ownership of large data structure
      - Transfer: Move data between processing stages
      - Finalize: Consume resources for cleanup
      - Archive: Move data to long-term storage

      Task: Implement move closures using FnOnce trait
      Requirements:
      - Create closures that take ownership of captures
      - Implement functions accepting FnOnce trait objects
      - Use move keyword for explicit ownership transfer
      - Handle consumed values in closure bodies
    requirements:
      - "Create closures implementing FnOnce trait for ownership transfer"
      - "Use move keyword to force ownership capture"
      - "Accept function parameters with FnOnce trait bounds"
      - "Handle value consumption in closure implementations"

  # Task 4: Higher-order functions and combinators
  - position: [4, 7]
    item_type: "combinator_system"
    name: "Function Combinator Framework"
    description: "Advanced system combining and chaining function operations"
    content: |
      // Complex functional operations requiring combinators
      Processing Pipeline:
      - Chain: Compose multiple processing functions
      - Branch: Conditional function application
      - Parallel: Execute functions concurrently
      - Retry: Wrapper for fault-tolerant execution

      Task: Implement higher-order functions and function combinators
      Requirements:
      - Create functions that return other functions
      - Implement function composition and chaining
      - Build conditional and branching combinators
      - Create retry and error-handling wrappers
    requirements:
      - "Implement functions that return closures or function objects"
      - "Create function composition and chaining mechanisms"
      - "Build conditional execution and branching combinators"
      - "Implement retry logic and error-handling function wrappers"

  # Task 5: Dynamic dispatch and boxed functions
  - position: [13, 7]
    item_type: "dynamic_dispatcher"
    name: "Dynamic Function Dispatcher"
    description: "System managing collections of functions with dynamic dispatch"
    content: |
      // Dynamic function management requiring trait objects
      Function Registry:
      - Handlers: Collection of event processing functions
      - Strategies: Pluggable algorithm implementations
      - Validators: Dynamic validation rule sets
      - Formatters: Runtime-configurable output formatters

      Task: Implement dynamic dispatch with boxed callable traits
      Requirements:
      - Store collections of Box<dyn Fn> trait objects
      - Implement function registration and lookup systems
      - Handle different function signatures dynamically
      - Create plugin-style architecture with callable traits
    requirements:
      - "Store and manage collections of Box<dyn Fn> trait objects"
      - "Implement dynamic function registration and dispatch"
      - "Handle multiple function signatures with trait objects"
      - "Create extensible plugin architecture using callable traits"

# Enemies represent functional programming challenges
enemies:
  - position: [4, 4]
    enemy_type: "borrow_conflict"
    name: "Closure Borrow Checker"
    health: 35
    description: "Borrow checking issues in closures - defeat with proper capture semantics"

  - position: [9, 4]
    enemy_type: "lifetime_puzzle"
    name: "Closure Lifetime Phantom"
    health: 40
    description: "Lifetime issues with captured references - defeat with lifetime management"

  - position: [13, 4]
    enemy_type: "move_confusion"
    name: "Move Semantics Confusion"
    health: 30
    description: "Unclear ownership in move closures - defeat with explicit move patterns"

  - position: [6, 8]
    enemy_type: "trait_object_trap"
    name: "Trait Object Complexity"
    health: 45
    description: "Complex trait object interactions - defeat with proper type erasure"

  - position: [11, 8]
    enemy_type: "recursion_loop"
    name: "Recursive Closure Loop"
    health: 38
    description: "Infinite recursion in closures - defeat with proper termination"

# Doors represent callable trait concept progression
doors:
  - position: [1, 4]
    door_type: "fn_door"
    name: "Fn Trait Gateway"
    key_requirement: "Immutable closure mastery"
    description: "Access to stateful closure operations"

  - position: [7, 5]
    door_type: "fnmut_door"
    name: "FnMut Trait Portal"
    key_requirement: "Mutable closure proficiency"
    description: "Enter ownership transfer zone"

  - position: [11, 5]
    door_type: "fnonce_door"
    name: "FnOnce Trait Chamber"
    key_requirement: "Move closure expertise"
    description: "Access to higher-order functions"

  - position: [16, 5]
    door_type: "combinator_door"
    name: "Combinator Vault"
    key_requirement: "Higher-order function skills"
    description: "Dynamic dispatch implementation area"

# Task definitions with learning objectives
tasks:
  - id: 1
    name: "Fn Trait Mastery"
    description: "Implement immutable closures using Fn trait for stateless operations"
    requirements:
      - "Create closures implementing Fn trait for multiple invocations"
      - "Design function parameters accepting Fn trait bounds"
      - "Use immutable closures for filtering and mapping operations"
      - "Demonstrate safe capture of immutable references"
    item_location: [2, 2]
    completion_message: "Fn trait mastered! Immutable closures for stateless operations achieved."

  - id: 2
    name: "FnMut Trait Implementation"
    description: "Create mutable closures using FnMut trait for stateful operations"
    requirements:
      - "Implement closures with FnMut trait for mutable state modification"
      - "Design function parameters with FnMut trait bounds"
      - "Create accumulator patterns using mutable closures"
      - "Handle mutable capture semantics and state management"
    item_location: [8, 2]
    completion_message: "FnMut trait perfected! Stateful closures with mutable captures implemented."

  - id: 3
    name: "FnOnce Trait Ownership"
    description: "Implement move closures using FnOnce trait for ownership transfer"
    requirements:
      - "Create closures implementing FnOnce trait for single consumption"
      - "Use move keyword for explicit ownership capture"
      - "Design function parameters accepting FnOnce trait bounds"
      - "Handle value consumption and ownership transfer patterns"
    item_location: [14, 2]
    completion_message: "FnOnce trait achieved! Ownership transfer through move closures mastered."

  - id: 4
    name: "Higher-Order Functions"
    description: "Build advanced function combinators and higher-order function systems"
    requirements:
      - "Create functions that return closures and function objects"
      - "Implement function composition and chaining mechanisms"
      - "Build conditional execution and branching combinators"
      - "Design retry logic and error-handling function wrappers"
    item_location: [4, 7]
    completion_message: "Higher-order functions complete! Advanced functional composition achieved."

  - id: 5
    name: "Dynamic Function Dispatch"
    description: "Implement dynamic dispatch systems using boxed callable trait objects"
    requirements:
      - "Store and manage collections of Box<dyn Fn> trait objects"
      - "Create dynamic function registration and dispatch mechanisms"
      - "Handle multiple function signatures with trait object polymorphism"
      - "Build extensible plugin architecture using callable traits"
    item_location: [13, 7]
    completion_message: "Dynamic dispatch mastered! Flexible function management with trait objects achieved."

completion_requirements:
  - "Complete all 5 callable trait tasks"
  - "Defeat all functional programming enemies"
  - "Open all callable trait doors"
  - "Demonstrate mastery of Fn, FnMut, FnOnce traits and advanced functional patterns"

final_message: "Level 20 Complete: Callable Traits Expert achieved! You've mastered functional programming with closures, higher-order functions, and dynamic dispatch. Ready for operator traits!"