name: "Level 7: Structs and Robot Systems"
grid_size: "12x10"
start_position: [0, 0]
max_turns: 200
fog_of_war: true
income_per_square: 2
message: |
  ü§ñ **LEVEL 7: Structs and Robot Systems**

  Build custom data structures to manage robot state, inventory, and navigation!

  Use structs to organize robot data and create methods for robot behavior.

hint_message: |
  **Struct Tips:**
  - Define structs to group related data (position, health, inventory)
  - Use `impl` blocks to add methods to structs
  - Methods can take `&self`, `&mut self`, or `self`
  - Structs can contain other structs and collections
  - Use `#[derive(Debug)]` to auto-generate Debug trait

rust_docs_url: "https://doc.rust-lang.org/rust-by-example/custom_types/structs.html"
obstacles: 8

enemies:
  - start_position: [3, 2]
    movement_pattern: "file:movement_patterns/guard_area.rs"
  - start_position: [8, 5]
    movement_pattern: "file:movement_patterns/horizontal_patrol.rs"
  - start_position: [5, 8]
    movement_pattern: "file:movement_patterns/vertical_patrol.rs"

doors:
  - position: [6, 3]
    initially_open: false
  - position: [4, 7]
    initially_open: false
  - position: [9, 8]
    initially_open: false

items:
  - name: "struct_blueprint"
    item_file: "items/struct_data.rs"
    spawn_randomly: false
    location: [2, 1]
  - name: "method_chip"
    item_file: "items/methods.rs"
    spawn_randomly: false
    location: [10, 3]
  - name: "inventory_system"
    item_file: "items/inventory.rs"
    spawn_randomly: false
    location: [1, 6]
  - name: "navigation_module"
    item_file: "items/navigation.rs"
    spawn_randomly: false
    location: [7, 9]
  - name: "goal_item"
    item_file: "items/level_complete.rs"
    spawn_randomly: false
    location: [11, 9]

tasks:
  - name: "Create Robot Position Struct"
    task_file: "learning_tests::level7_task1_position_struct::level7_task1_tests"
    task_message: |
      ## Task 1: Create Robot Position Struct

      Create a Position struct to track robot coordinates and implement movement methods.

      **Your goal:** Build a position system for the robot using structs and methods.

      **Requirements:**
      ```rust
      #[derive(Debug, Clone, Copy)]
      struct Position {
          x: i32,
          y: i32,
      }

      impl Position {
          // Constructor method
          fn new(x: i32, y: i32) -> Self {
              Position { x, y }
          }

          // Calculate distance to another position
          fn distance_to(&self, other: &Position) -> f64 {
              let dx = (self.x - other.x) as f64;
              let dy = (self.y - other.y) as f64;
              (dx * dx + dy * dy).sqrt()
          }

          // Move in a direction
          fn move_by(&mut self, dx: i32, dy: i32) {
              self.x += dx;
              self.y += dy;
          }

          // Check if position is within bounds
          fn is_valid(&self, width: i32, height: i32) -> bool {
              self.x >= 0 && self.x < width && self.y >= 0 && self.y < height
          }
      }

      fn main() {
          // Create robot starting position
          let mut robot_pos = Position::new(0, 0);
          println!("Robot starts at: {:?}", robot_pos);

          // Move robot to collect struct_blueprint at (2, 1)
          robot_pos.move_by(2, 1);
          println!("Robot moved to: {:?}", robot_pos);

          // Check if move is valid
          if robot_pos.is_valid(12, 10) {
              println!("Position is valid within 12x10 grid");
          }

          // Calculate distance to goal
          let goal = Position::new(11, 9);
          let distance = robot_pos.distance_to(&goal);
          println!("Distance to goal: {:.2} units", distance);

          // Navigate to collect items using position struct
          let items = vec![Position::new(2, 1), Position::new(10, 3), Position::new(1, 6)];
          for item_pos in items {
              println!("Item at {:?}, distance: {:.2}", item_pos, robot_pos.distance_to(&item_pos));
          }
      }
      ```

    completion_message: |
      ‚úÖ **Excellent!** You've created a Position struct with methods!

      **What you learned:**
      - Defining structs with named fields
      - Adding methods with `impl` blocks
      - Constructor patterns with `new()`
      - Using `&self` and `&mut self` in methods

    start_task_message: "Let's create a Position struct to track robot coordinates!"

  - name: "Robot State Management Struct"
    task_file: "learning_tests::level7_task2_robot_state::level7_task2_tests"
    task_message: |
      ## Task 2: Robot State Management Struct

      Create a comprehensive Robot struct to manage position, health, energy, and status.

      **Your goal:** Build a complete robot state management system.

      **Requirements:**
      ```rust
      #[derive(Debug)]
      struct Robot {
          position: Position,
          health: u32,
          energy: u32,
          is_active: bool,
          scan_range: u32,
      }

      impl Robot {
          fn new(x: i32, y: i32) -> Self {
              Robot {
                  position: Position::new(x, y),
                  health: 100,
                  energy: 100,
                  is_active: true,
                  scan_range: 2,
              }
          }

          // Robot actions that consume energy
          fn move_to(&mut self, x: i32, y: i32) -> bool {
              if self.energy < 10 {
                  println!("Insufficient energy to move!");
                  return false;
              }

              self.position.x = x;
              self.position.y = y;
              self.energy -= 10;
              println!("Robot moved to ({}, {}), energy: {}", x, y, self.energy);
              true
          }

          fn scan_area(&mut self) -> Vec<String> {
              if self.energy < 5 {
                  println!("Insufficient energy to scan!");
                  return vec![];
              }

              self.energy -= 5;
              let mut scan_results = vec![];

              // Simulate scanning around robot position
              for dx in -1..=1 {
                  for dy in -1..=1 {
                      let scan_x = self.position.x + dx;
                      let scan_y = self.position.y + dy;

                      if scan_x >= 0 && scan_y >= 0 {
                          scan_results.push(format!("({},{}):clear", scan_x, scan_y));
                      }
                  }
              }

              println!("Scanned {} positions, energy: {}", scan_results.len(), self.energy);
              scan_results
          }

          fn recharge(&mut self, amount: u32) {
              self.energy = (self.energy + amount).min(100);
              println!("Robot recharged, energy: {}", self.energy);
          }

          fn take_damage(&mut self, damage: u32) {
              self.health = self.health.saturating_sub(damage);
              if self.health == 0 {
                  self.is_active = false;
                  println!("Robot disabled!");
              } else {
                  println!("Robot took {} damage, health: {}", damage, self.health);
              }
          }

          fn status_report(&self) {
              println!("=== Robot Status ===");
              println!("Position: {:?}", self.position);
              println!("Health: {}/100", self.health);
              println!("Energy: {}/100", self.energy);
              println!("Active: {}", self.is_active);
          }
      }

      fn main() {
          let mut robot = Robot::new(0, 0);
          robot.status_report();

          // Navigate through the level avoiding enemies
          let navigation_path = vec![(1, 0), (2, 0), (2, 1)];

          for (x, y) in navigation_path {
              if robot.move_to(x, y) {
                  robot.scan_area();
              }
          }

          // Simulate encountering enemy
          println!("Enemy encounter!");
          robot.take_damage(25);

          // Recharge at power station
          robot.recharge(30);

          robot.status_report();
      }
      ```

    completion_message: |
      ‚úÖ **Great work!** You've created a comprehensive Robot struct!

      **What you learned:**
      - Complex struct composition with multiple fields
      - State management through methods
      - Energy/resource systems
      - Method chaining and return values

    start_task_message: "Let's build a complete robot state management system!"

  - name: "Inventory Management System"
    task_file: "learning_tests::level7_task3_inventory::level7_task3_tests"
    task_message: |
      ## Task 3: Inventory Management System

      Create an inventory system using structs and collections to manage robot items.

      **Your goal:** Build a complete item collection and inventory management system.

      **Requirements:**
      ```rust
      #[derive(Debug, Clone)]
      struct Item {
          name: String,
          item_type: ItemType,
          value: u32,
      }

      #[derive(Debug, Clone, PartialEq)]
      enum ItemType {
          Energy,
          Health,
          Key,
          Tool,
          Data,
      }

      #[derive(Debug)]
      struct Inventory {
          items: Vec<Item>,
          max_capacity: usize,
      }

      impl Inventory {
          fn new(capacity: usize) -> Self {
              Inventory {
                  items: Vec::new(),
                  max_capacity: capacity,
              }
          }

          fn add_item(&mut self, item: Item) -> bool {
              if self.items.len() >= self.max_capacity {
                  println!("Inventory full! Cannot add {}", item.name);
                  return false;
              }

              println!("Added {} to inventory", item.name);
              self.items.push(item);
              true
          }

          fn use_item(&mut self, name: &str) -> Option<Item> {
              if let Some(index) = self.items.iter().position(|item| item.name == name) {
                  let item = self.items.remove(index);
                  println!("Used item: {}", item.name);
                  Some(item)
              } else {
                  println!("Item '{}' not found in inventory", name);
                  None
              }
          }

          fn count_by_type(&self, item_type: &ItemType) -> usize {
              self.items.iter().filter(|item| &item.item_type == item_type).count()
          }

          fn total_value(&self) -> u32 {
              self.items.iter().map(|item| item.value).sum()
          }

          fn list_items(&self) {
              println!("=== Inventory ({}/{}) ===", self.items.len(), self.max_capacity);
              for (i, item) in self.items.iter().enumerate() {
                  println!("{}: {} ({:?}) - Value: {}", i + 1, item.name, item.item_type, item.value);
              }
          }
      }

      // Enhanced Robot with inventory
      struct RobotWithInventory {
          robot: Robot,
          inventory: Inventory,
      }

      impl RobotWithInventory {
          fn new(x: i32, y: i32) -> Self {
              RobotWithInventory {
                  robot: Robot::new(x, y),
                  inventory: Inventory::new(10),
              }
          }

          fn collect_item(&mut self, item: Item) -> bool {
              if self.inventory.add_item(item.clone()) {
                  println!("Robot collected: {}", item.name);
                  true
              } else {
                  false
              }
          }

          fn open_door_with_key(&mut self) -> bool {
              if self.inventory.use_item("door_key").is_some() {
                  println!("Door opened with key!");
                  true
              } else {
                  println!("No key available to open door");
                  false
              }
          }

          fn use_health_item(&mut self) {
              if let Some(item) = self.inventory.items.iter().find(|i| i.item_type == ItemType::Health).cloned() {
                  if self.inventory.use_item(&item.name).is_some() {
                      // Restore health based on item value
                      self.robot.health = (self.robot.health + item.value).min(100);
                      println!("Health restored to {}", self.robot.health);
                  }
              } else {
                  println!("No health items available");
              }
          }
      }

      fn main() {
          let mut robot = RobotWithInventory::new(0, 0);

          // Simulate collecting items from level
          let level_items = vec![
              Item { name: "Energy Cell".to_string(), item_type: ItemType::Energy, value: 20 },
              Item { name: "Door Key".to_string(), item_type: ItemType::Key, value: 1 },
              Item { name: "Health Pack".to_string(), item_type: ItemType::Health, value: 30 },
              Item { name: "Struct Blueprint".to_string(), item_type: ItemType::Data, value: 100 },
          ];

          for item in level_items {
              robot.collect_item(item);
          }

          robot.inventory.list_items();

          // Use items for level navigation
          println!("Energy items: {}", robot.inventory.count_by_type(&ItemType::Energy));
          println!("Total inventory value: {}", robot.inventory.total_value());

          // Simulate taking damage
          robot.robot.take_damage(40);
          robot.use_health_item();

          // Use key to open door
          robot.open_door_with_key();

          robot.inventory.list_items();
      }
      ```

    completion_message: |
      ‚úÖ **Perfect!** You've created a sophisticated inventory system!

      **What you learned:**
      - Using Vec<T> for dynamic collections
      - Enum variants for type safety
      - Option<T> for safe item retrieval
      - Complex struct interactions

    start_task_message: "Let's build an inventory system for item management!"

  - name: "Navigation and Pathfinding Structs"
    task_file: "learning_tests::level7_task4_navigation::level7_task4_tests"
    task_message: |
      ## Task 4: Navigation and Pathfinding Structs

      Create navigation structs to handle robot pathfinding and obstacle avoidance.

      **Your goal:** Build a navigation system that can plan paths around obstacles and enemies.

      **Requirements:**
      ```rust
      #[derive(Debug, Clone, Copy, PartialEq)]
      enum CellType {
          Empty,
          Obstacle,
          Enemy,
          Door,
          Item,
          Goal,
      }

      #[derive(Debug)]
      struct GameMap {
          width: i32,
          height: i32,
          cells: Vec<Vec<CellType>>,
          robot_position: Position,
      }

      impl GameMap {
          fn new(width: i32, height: i32) -> Self {
              let cells = vec![vec![CellType::Empty; height as usize]; width as usize];
              GameMap {
                  width,
                  height,
                  cells,
                  robot_position: Position::new(0, 0),
              }
          }

          fn set_cell(&mut self, x: i32, y: i32, cell_type: CellType) {
              if self.is_valid_position(x, y) {
                  self.cells[x as usize][y as usize] = cell_type;
              }
          }

          fn get_cell(&self, x: i32, y: i32) -> CellType {
              if self.is_valid_position(x, y) {
                  self.cells[x as usize][y as usize]
              } else {
                  CellType::Obstacle
              }
          }

          fn is_valid_position(&self, x: i32, y: i32) -> bool {
              x >= 0 && x < self.width && y >= 0 && y < self.height
          }

          fn can_move_to(&self, x: i32, y: i32) -> bool {
              match self.get_cell(x, y) {
                  CellType::Empty | CellType::Item | CellType::Goal => true,
                  _ => false,
              }
          }

          fn find_path_to(&self, target: Position) -> Vec<Position> {
              let mut path = vec![];
              let current = self.robot_position;

              // Simple pathfinding: move towards target
              let dx = if target.x > current.x { 1 } else if target.x < current.x { -1 } else { 0 };
              let dy = if target.y > current.y { 1 } else if target.y < current.y { -1 } else { 0 };

              let mut next = current;

              while next != target {
                  // Try to move horizontally first
                  if dx != 0 && self.can_move_to(next.x + dx, next.y) {
                      next.x += dx;
                  }
                  // Then try vertically
                  else if dy != 0 && self.can_move_to(next.x, next.y + dy) {
                      next.y += dy;
                  }
                  // If blocked, try alternative routes
                  else {
                      // Try moving around obstacles
                      let alternatives = [(0, 1), (0, -1), (1, 0), (-1, 0)];
                      let mut moved = false;

                      for (alt_dx, alt_dy) in alternatives {
                          let alt_x = next.x + alt_dx;
                          let alt_y = next.y + alt_dy;

                          if self.can_move_to(alt_x, alt_y) {
                              next.x = alt_x;
                              next.y = alt_y;
                              moved = true;
                              break;
                          }
                      }

                      if !moved {
                          println!("Path blocked, cannot reach target");
                          break;
                      }
                  }

                  path.push(next);

                  // Prevent infinite loops
                  if path.len() > 50 {
                      break;
                  }
              }

              path
          }

          fn scan_around_robot(&self, range: i32) -> Vec<(Position, CellType)> {
              let mut scan_results = vec![];

              for dx in -range..=range {
                  for dy in -range..=range {
                      if dx == 0 && dy == 0 { continue; } // Skip robot position

                      let scan_x = self.robot_position.x + dx;
                      let scan_y = self.robot_position.y + dy;

                      if self.is_valid_position(scan_x, scan_y) {
                          let cell_type = self.get_cell(scan_x, scan_y);
                          scan_results.push((Position::new(scan_x, scan_y), cell_type));
                      }
                  }
              }

              scan_results
          }

          fn move_robot(&mut self, new_position: Position) -> bool {
              if self.can_move_to(new_position.x, new_position.y) {
                  self.robot_position = new_position;
                  println!("Robot moved to {:?}", new_position);
                  true
              } else {
                  println!("Cannot move to {:?} - blocked", new_position);
                  false
              }
          }
      }

      fn main() {
          // Create map matching level layout (12x10)
          let mut game_map = GameMap::new(12, 10);

          // Set up obstacles (from level configuration)
          game_map.set_cell(3, 2, CellType::Enemy);
          game_map.set_cell(8, 5, CellType::Enemy);
          game_map.set_cell(5, 8, CellType::Enemy);
          game_map.set_cell(6, 3, CellType::Door);
          game_map.set_cell(4, 7, CellType::Door);

          // Set up items from level
          game_map.set_cell(2, 1, CellType::Item);
          game_map.set_cell(10, 3, CellType::Item);
          game_map.set_cell(1, 6, CellType::Item);
          game_map.set_cell(11, 9, CellType::Goal);

          println!("Initial robot position: {:?}", game_map.robot_position);

          // Scan around robot
          let scan_results = game_map.scan_around_robot(2);
          println!("Scan results: {} cells detected", scan_results.len());

          for (pos, cell_type) in scan_results.iter().take(5) {
              println!("  {:?}: {:?}", pos, cell_type);
          }

          // Plan path to first item
          let item_position = Position::new(2, 1);
          let path = game_map.find_path_to(item_position);

          println!("Path to item at {:?}: {} steps", item_position, path.len());

          // Execute path
          for (i, step) in path.iter().enumerate().take(5) {
              if game_map.move_robot(*step) {
                  println!("Step {}: Moved to {:?}", i + 1, step);
              } else {
                  println!("Step {}: Move blocked", i + 1);
              }
          }

          // Check if we can reach the goal
          let goal_position = Position::new(11, 9);
          let goal_path = game_map.find_path_to(goal_position);
          println!("Path to goal: {} steps planned", goal_path.len());
      }
      ```

    completion_message: |
      ‚úÖ **Amazing!** You've created a complete navigation system!

      **What you learned:**
      - 2D vector grids for game maps
      - Enum-based cell type systems
      - Pathfinding algorithms
      - Complex struct method interactions

    start_task_message: "Let's build a navigation system for robot pathfinding!"

  - name: "Complete Robot Control System"
    task_file: "learning_tests::level7_task5_complete_robot::level7_task5_tests"
    task_message: |
      ## Task 5: Complete Robot Control System

      Combine all struct concepts into a complete robot control system for level completion.

      **Your goal:** Create a master robot controller that manages all subsystems.

      **Requirements:**
      ```rust
      // Combine all previous structs into a complete system
      struct MasterRobotController {
          robot: RobotWithInventory,
          game_map: GameMap,
          mission_objectives: Vec<Objective>,
      }

      #[derive(Debug, Clone)]
      struct Objective {
          objective_type: ObjectiveType,
          target_position: Position,
          completed: bool,
      }

      #[derive(Debug, Clone, PartialEq)]
      enum ObjectiveType {
          CollectItem(String),
          OpenDoor,
          AvoidEnemy,
          ReachGoal,
      }

      impl MasterRobotController {
          fn new() -> Self {
              let mut game_map = GameMap::new(12, 10);

              // Set up level 7 layout
              game_map.set_cell(3, 2, CellType::Enemy);
              game_map.set_cell(8, 5, CellType::Enemy);
              game_map.set_cell(5, 8, CellType::Enemy);
              game_map.set_cell(6, 3, CellType::Door);
              game_map.set_cell(4, 7, CellType::Door);
              game_map.set_cell(2, 1, CellType::Item);
              game_map.set_cell(10, 3, CellType::Item);
              game_map.set_cell(1, 6, CellType::Item);
              game_map.set_cell(7, 9, CellType::Item);
              game_map.set_cell(11, 9, CellType::Goal);

              let objectives = vec![
                  Objective {
                      objective_type: ObjectiveType::CollectItem("struct_blueprint".to_string()),
                      target_position: Position::new(2, 1),
                      completed: false,
                  },
                  Objective {
                      objective_type: ObjectiveType::CollectItem("method_chip".to_string()),
                      target_position: Position::new(10, 3),
                      completed: false,
                  },
                  Objective {
                      objective_type: ObjectiveType::CollectItem("inventory_system".to_string()),
                      target_position: Position::new(1, 6),
                      completed: false,
                  },
                  Objective {
                      objective_type: ObjectiveType::CollectItem("navigation_module".to_string()),
                      target_position: Position::new(7, 9),
                      completed: false,
                  },
                  Objective {
                      objective_type: ObjectiveType::ReachGoal,
                      target_position: Position::new(11, 9),
                      completed: false,
                  },
              ];

              MasterRobotController {
                  robot: RobotWithInventory::new(0, 0),
                  game_map,
                  mission_objectives: objectives,
              }
          }

          fn execute_mission(&mut self) -> bool {
              println!("üöÄ Starting Robot Mission: Struct Collection");

              for objective in &mut self.mission_objectives {
                  if objective.completed {
                      continue;
                  }

                  println!("\n--- Executing objective: {:?} ---", objective.objective_type);

                  // Plan path to objective
                  let path = self.game_map.find_path_to(objective.target_position);

                  if path.is_empty() {
                      println!("No path found to objective!");
                      continue;
                  }

                  // Execute path
                  for step in path {
                      // Check for enemies before moving
                      let scan_results = self.game_map.scan_around_robot(1);
                      let enemy_nearby = scan_results.iter().any(|(_, cell)| *cell == CellType::Enemy);

                      if enemy_nearby {
                          println!("‚ö†Ô∏è Enemy detected! Taking evasive action...");
                          self.robot.robot.take_damage(10);

                          // Use health item if available
                          if self.robot.robot.health < 50 {
                              self.robot.use_health_item();
                          }
                      }

                      // Move robot
                      if self.game_map.move_robot(step) {
                          self.robot.robot.position = step;
                      }

                      // Check if we reached the objective
                      if step == objective.target_position {
                          match &objective.objective_type {
                              ObjectiveType::CollectItem(item_name) => {
                                  let item = Item {
                                      name: item_name.clone(),
                                      item_type: ItemType::Data,
                                      value: 50,
                                  };
                                  if self.robot.collect_item(item) {
                                      objective.completed = true;
                                      println!("‚úÖ Collected: {}", item_name);
                                  }
                              }
                              ObjectiveType::ReachGoal => {
                                  objective.completed = true;
                                  println!("‚úÖ Reached goal!");
                              }
                              _ => {}
                          }
                          break;
                      }
                  }
              }

              // Check mission completion
              let completed_objectives = self.mission_objectives.iter().filter(|obj| obj.completed).count();
              let total_objectives = self.mission_objectives.len();

              println!("\n=== Mission Summary ===");
              println!("Objectives completed: {}/{}", completed_objectives, total_objectives);

              self.robot.inventory.list_items();
              self.robot.robot.status_report();

              completed_objectives == total_objectives
          }

          fn emergency_procedures(&mut self) {
              println!("üö® Emergency procedures activated!");

              if self.robot.robot.health < 30 {
                  println!("Critical health - using all health items");
                  while self.robot.inventory.count_by_type(&ItemType::Health) > 0 {
                      self.robot.use_health_item();
                  }
              }

              if self.robot.robot.energy < 20 {
                  println!("Low energy - emergency recharge");
                  self.robot.robot.recharge(50);
              }
          }
      }

      fn main() {
          let mut controller = MasterRobotController::new();

          println!("Initializing Master Robot Controller...");
          controller.robot.robot.status_report();

          // Execute the mission
          let success = controller.execute_mission();

          if success {
              println!("\nüéâ MISSION ACCOMPLISHED!");
              println!("All struct-based systems functioning perfectly!");
          } else {
              println!("\n‚ùå Mission incomplete - activating emergency procedures");
              controller.emergency_procedures();
          }

          println!("\nü§ñ Robot systems demonstration complete!");
      }
      ```

    completion_message: |
      üéâ **Outstanding!** You've mastered structs and built a complete robot system!

      **What you accomplished:**
      - Complex struct composition and relationships
      - Method implementations for robot behavior
      - Game mechanics integration (movement, scanning, inventory)
      - Mission management and objective tracking
      - Error handling and emergency procedures

      **You're ready for enums and advanced pattern matching!**

    start_task_message: "Let's combine everything into a master robot control system!"

starting_code: |
  // Level 7: Structs and Robot Systems
  // Build custom data structures for robot management

  // TODO: Task 1 - Define Position struct
  // #[derive(Debug, Clone, Copy)]
  // struct Position {
  //     x: i32,
  //     y: i32,
  // }

  // TODO: Task 2 - Define Robot struct
  // #[derive(Debug)]
  // struct Robot {
  //     position: Position,
  //     health: u32,
  //     energy: u32,
  //     is_active: bool,
  // }

  // TODO: Task 3 - Define Item and Inventory structs
  // #[derive(Debug, Clone)]
  // struct Item {
  //     name: String,
  //     item_type: ItemType,
  //     value: u32,
  // }

  fn main() {
      println!("Level 7: Structs and Robot Systems");

      // TODO: Task 1 - Create and use Position struct
      // let mut robot_pos = Position::new(0, 0);
      // println!("Robot position: {:?}", robot_pos);

      // TODO: Task 2 - Create Robot with state management
      // let mut robot = Robot::new(0, 0);
      // robot.move_to(2, 1);
      // robot.scan_area();

      // TODO: Task 3 - Set up inventory system
      // let mut inventory = Inventory::new(10);
      // let item = Item { name: "Energy Cell".to_string(), item_type: ItemType::Energy, value: 20 };
      // inventory.add_item(item);

      // TODO: Task 4 - Create navigation system
      // let mut game_map = GameMap::new(12, 10);
      // game_map.set_cell(3, 2, CellType::Enemy);

      // TODO: Task 5 - Complete robot control system
      // let mut controller = MasterRobotController::new();
      // controller.execute_mission();

      println!("Complete all tasks to build a complete robot system!");
  }

achievement_message: "üéâ Incredible! You've mastered structs and built sophisticated robot systems!"
next_level_hint: "Next: Enums, pattern matching, and state machines!"
completion_flag: "goal"